#+TITLE:       Emacs Settings
#+EMAIL:       soonho.kong@gmail.com
#+STARTUP:     odd fold
#+LANGUAGE:    en
#+OPTIONS:     skip:nil toc:nil
#+HTML_HEAD:   <link rel="publisher" href="https://www.cs.cmu.edu/~soonhok" />

* Personal Information
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Soonho Kong"
        user-mail-address "soonho.kong@gmail.com")
#+END_SRC

* Platform-dependent
** macOS
*** "ls does not support --dired; see ‘dired-use-ls-dired’ for more details."
#+BEGIN_SRC emacs-lisp
  (when (string= system-type "darwin")       
    (setq dired-use-ls-dired nil))
#+END_SRC
*** Lion-style Fullscreen
#+BEGIN_SRC emacs-lisp
  (when (string= system-type "darwin")       
    (setq ns-use-native-fullscreen nil))
#+END_SRC
*** Bind M-` to other-frame
#+BEGIN_SRC emacs-lisp
  (when (string= system-type "darwin")       
    (global-set-key (kbd "M-`") 'other-frame))
#+END_SRC
** Linux
*** Fullscreen
#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'gnu/linux)
      (progn
        (defun toggle-fullscreen (&optional f)
          (interactive)
          (let ((current-value (frame-parameter nil 'fullscreen)))
            (set-frame-parameter nil 'fullscreen
                                 (if (equal 'fullboth current-value)
                                     (if (boundp 'old-fullscreen) old-fullscreen nil)
                                   (progn (setq old-fullscreen current-value)
                                          'fullboth)))))
        (global-set-key [(ctrl f2)] 'toggle-fullscreen)
        (add-hook 'after-make-frame-functions 'toggle-fullscreen)))

  (add-hook 'window-setup-hook 'toggle-frame-fullscreen t)
#+END_SRC
* Basics
** Display Time
#+BEGIN_SRC emacs-lisp
  (setq display-time-default-load-average nil)
  (setq display-time-use-mail-icon t)
  (setq display-time-24hr-format t)
  (display-time-mode t)
#+END_SRC
** TeX Input Method
#+BEGIN_SRC emacs-lisp
(setq default-input-method 'TeX)
#+END_SRC
** Encoding
#+BEGIN_SRC emacs-lisp
(set-language-environment "UTF-8")
(setq buffer-file-coding-system 'utf-8-unix)
(setq default-file-name-coding-system 'utf-8-unix)
(setq default-keyboard-coding-system 'utf-8-unix)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix))
(setq default-sendmail-coding-system 'utf-8-unix)
(setq default-terminal-coding-system 'utf-8-unix)
#+END_SRC

** Server
#+BEGIN_SRC emacs-lisp
(load "server")
(unless (server-running-p) (server-start))
#+END_SRC
** Use PATH
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :init (exec-path-from-shell-initialize))
#+END_SRC
** Fonts
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil
                      :family "Monaco" :height 125 :weight 'normal)
#+END_SRC
** Unicode Font Setup
#+BEGIN_SRC emacs-lisp
  (use-package unicode-fonts
    :config (unicode-fonts-setup))
#+END_SRC
** Map command key to meta
#+BEGIN_SRC emacs-lisp
  (setq mac-command-modifier 'meta)
#+END_SRC
** Backup Files
#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
  (setq delete-old-versions -1)
  (setq version-control t)
  (setq vc-make-backup-files t)
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC
** Turn off newbie stuff
#+BEGIN_SRC emacs-lisp
  (if (display-graphic-p)
      (progn
        (tool-bar-mode -1)
        (scroll-bar-mode -1)))
  (blink-cursor-mode -1)
  (setq inhibit-startup-message t)
  (setq initial-scratch-message nil)
  (setq wdired-allow-to-change-permissions t)
  (defalias 'yes-or-no-p 'y-or-n-p)
  (setq dabbrev-case-distinction nil)
  (setq dabbrev-case-fold-search nil)
  (setq echo-keystrokes 0.1)
  (setq delete-active-region nil)
  (column-number-mode t)
  (transient-mark-mode t)
  (global-font-lock-mode t)

  (setq font-lock-maximum-decoration t)
  (setq font-lock-maximum-size nil)
  (setq display-time-24hr-format t)
#+END_SRC
** Matching Parens
From https://www.gnu.org/software/emacs/manual/html_node/efaq/Matching-parentheses.html
#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
  (global-set-key "%" 'match-paren)
  (defun match-paren (arg)
    "Go to the matching paren if on a paren; otherwise insert %."
    (interactive "p")
    (cond ((looking-at "\\s(") (forward-list 1) (backward-char 1))
	  ((looking-at "\\s)") (forward-char 1) (backward-list 1))
	  (t (self-insert-command (or arg 1)))))
#+END_SRC
** Color Theme
#+BEGIN_SRC emacs-lisp
  (use-package nord-theme)
#+END_SRC

** Ace window
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind ("M-p" . 'ace-window)
    :config 
      (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
      (setq aw-background t)
  )
#+END_SRC

** Diminish
#+BEGIN_SRC 
(use-package diminish)
#+END_SRC
** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode)
#+END_SRC
** Whitespace Cleanup
#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :hook (prog-mode-hook . ws-butler-mode))
#+END_SRC
** Global unsets
#+BEGIN_SRC emacs-lisp
;; M-` invokes tmm-menubar; disable it.
(global-unset-key "\M-`")
#+END_SRC
* Useful emacs-lisp libraries
#+BEGIN_SRC emacs-lisp
  (use-package dash)
  (use-package f)
#+END_SRC
* Terminal
From http://rawsyntax.com/blog/learn-emacs-zsh-and-multi-term/
#+BEGIN_SRC emacs-lisp
  (use-package multi-term
    :config
      (setq multi-term-program "/bin/zsh"))
  (add-hook 'term-mode-hook
	    (lambda ()
	      (setq term-buffer-maximum-size 10000)))
  (defcustom term-unbind-key-list
    '("C-z" "C-x" "C-c" "C-h" "C-y" "<ESC>")
    "The key list that will need to be unbind."
    :type 'list
    :group 'multi-term)

  (defcustom term-bind-key-alist
    '(
      ("C-c C-c" . term-interrupt-subjob)
      ("C-p" . previous-line)
      ("C-n" . next-line)
      ("C-s" . isearch-forward)
      ("C-r" . isearch-backward)
      ("C-m" . term-send-raw)
      ("M-f" . term-send-forward-word)
      ("M-b" . term-send-backward-word)
      ("M-o" . term-send-backspace)
      ("M-p" . term-send-up)
      ("M-n" . term-send-down)
      ("M-M" . term-send-forward-kill-word)
      ("M-N" . term-send-backward-kill-word)
      ("M-r" . term-send-reverse-search-history)
      ("M-," . term-send-input)
      ("M-." . comint-dynamic-complete))
    "The key alist that will need to be bind.
  If you do not like default setup, modify it, with (KEY . COMMAND) format."
    :type 'alist
    :group 'multi-term)
  (add-hook 'term-mode-hook
	    (lambda ()
	      (add-to-list 'term-bind-key-alist '("M-[" . multi-term-prev))
	      (add-to-list 'term-bind-key-alist '("M-]" . multi-term-next))))
  (add-hook 'term-mode-hook
	    (lambda ()
	      (define-key term-raw-map (kbd "C-y") 'term-paste)))
  (defun buffer-exists (bufname) (not (eq nil (get-buffer bufname))))

  (defun soonho-visor-style-terminal ()
    (interactive)
    (let ((name_of_terminal_buffer "*terminal<1>*"))
      (if (buffer-exists name_of_terminal_buffer)
	  ;; If the terminal buffer exists
	  (if (string= (buffer-name) name_of_terminal_buffer)
	      ;; and we are in the terminal buffer
	      ;; then move to the previous buffer
	      (previous-buffer)
	    ;; otherwise, switch to terminal buffer (move to the other
	    ;; frame in the buffer is there, instead of creating one in
	    ;; the current frame!
	    (switch-to-buffer name_of_terminal_buffer)
	    )
	;; If the terminal buffer doesn't exist, create one
	(multi-term)
	)))
  (global-set-key (kbd "C-`") 'soonho-visor-style-terminal)
#+END_SRC
* Helm settings
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :config
    (setq helm-mode-fuzzy-match t)
    (setq helm-completion-in-region-fuzzy-match t)
    (helm-mode t)
    (diminish 'helm-mode)
    (global-set-key (kbd "M-x") 'helm-M-x)
    (global-set-key (kbd "C-c f r") 'helm-recentf)
    (global-set-key (kbd "C-x C-f") 'helm-find-files)
    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-z")  'helm-select-action)
    (setq helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
	  helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
	  helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
	  helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
	  helm-ff-file-name-history-use-recentf t))
  (use-package helm-flx
    :config
    (helm-flx-mode t)
    (setq helm-flx-for-helm-find-files t ;; t by default
	  helm-flx-for-helm-locate t) ;; nil by default
    (setq helm-M-x-fuzzy-match                  t
	  helm-bookmark-show-location           t
	  helm-buffers-fuzzy-matching           t
	  helm-completion-in-region-fuzzy-match t
	  helm-file-cache-fuzzy-match           t
	  helm-imenu-fuzzy-match                t
	  helm-mode-fuzzy-match                 t
	  helm-locate-fuzzy-match               t
	  helm-quick-update                     t
	  helm-recentf-fuzzy-match              t
	  helm-semantic-fuzzy-match             t))
  (use-package helm-ag)
  (use-package helm-company)
  (use-package helm-projectile
    :init
      (helm-projectile-on)
    :config
      (setq projectile-completion-system 'helm))
#+END_SRC
* Silver Searcher
#+BEGIN_SRC emacs-lisp
  (use-package ag)
#+END_SRC
* Projectile
#+BEGIN_SRC emacs-lisp
  ;; Projectile - Project interaction library
  (use-package projectile
    :config
      (setq projectile-indexing-method 'git)
      (setq projectile-enable-caching t)
      (setq projectile-keymap-prefix (kbd "C-c C-p"))
      (setq projectile-switch-project-action 'projectile-dired)
      (add-to-list 'projectile-other-file-alist '("cc" "h")) ;; switch from cc -> h
      (add-to-list 'projectile-other-file-alist '("h" "cc"))
    :bind ("M-o" . 'projectile-find-other-file)
    :hook (after-init . projectile-mode)
    :diminish projectile-mode)
#+END_SRC
* On-the-fly Syntax Check (Flycheck)
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :commands (flycheck-get-checker-for-buffer
               flycheck-may-enable-mode)
    :hook (c++-mode . flycheck-mode)
    :init
      (global-flycheck-mode)
      (diminish 'flycheck-mode "fc"))
#+END_SRC
* Auto Completion (Company)
#+BEGIN_SRC emacs-lisp
  (use-package company
    :defer t
    :bind
      (("M-/" . company-complete))
    :init
      (global-company-mode)
    :config
        (set-variable 'company-idle-delay 0.1)
    :hook (c++-mode . company-mode)
    :diminish company-mode)
#+END_SRC
* GIT
** Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :config
    (setq vc-display-status nil)
    ;; full screen magit-status
    (defadvice magit-status (around magit-fullscreen activate)
      (window-configuration-to-register :magit-fullscreen)
      ad-do-it
      (delete-other-windows))
    (defun magit-quit-session ()
      "Restores the previous window configuration and kills the magit buffer"
      (interactive)
      (kill-buffer)
      (jump-to-register :magit-fullscreen))
    (setq magit-last-seen-setup-instructions "1.4.0")
    (setq magit-refresh-status-buffer nil)
    (setq auto-revert-buffer-list-filter
          'magit-auto-revert-repository-buffers-p)
    (setq magit-commit-show-diff nil
          magit-revert-buffers 1)
    :bind 
    (("C-x g" . magit-status)
     :map magit-status-mode-map
     ("q" . magit-quit-session)))
#+END_SRC
** Git Gutter
#+BEGIN_SRC emacs-lisp
(if (display-graphic-p)
   (use-package git-gutter-fringe
     :ensure t
     :init (global-git-gutter-mode))
 (use-package git-gutter
  :ensure t
  :init (global-git-gutter-mode)))
#+END_SRC
* Editor Config
#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :init
      (editorconfig-mode))
#+END_SRC
* Language-Specific
** C++
*** Basics
#+BEGIN_SRC emacs-lisp
  (use-package modern-cpp-font-lock)
#+END_SRC
*** ELDOC
#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :hook (c++-mode . eldoc-mode)
  :diminish eldoc-mode)
#+END_SRC
*** YCMD
#+BEGIN_SRC emacs-lisp
  (use-package ycmd
    :bind (("C-c y g" . ycmd-goto))
    :hook (c++-mode . ycmd-mode)
    :config
      (set-variable 'ycmd-server-command `("python2"
					   ,(expand-file-name "~/work/ycmd/ycmd")))
      (set-variable 'ycmd-parse-conditions '(save new-line buffer-focus))
      (set-variable 'ycmd-idle-change-delay 0.1)
      (set-variable 'url-show-status nil)
      (set-variable 'ycmd-extra-conf-whitelist '("~/work/*"))
      (set-variable 'ycmd-request-message-level -1))

  (use-package company-ycmd
    ;; We're trying out ycmd. No need for original clang support.
    :init 
      (setq company-backends (remove 'company-clang company-backends))
    ;; :after company
    :config 
      (company-ycmd-setup))

  (use-package flycheck-ycmd
    ;; :after flycheck
    :config 
      (flycheck-ycmd-setup)
      ;; Make sure the flycheck cache sees the parse results
      (add-hook 'ycmd-file-parse-result-hook 'flycheck-ycmd--cache-parse-results)
      ;; Add the ycmd checker to the list of available checkers
      (add-to-list 'flycheck-checkers 'ycmd)
      (when (not (display-graphic-p))
	(setq flycheck-indication-mode nil)))
  (require 'ycmd-eldoc)
  (add-hook 'ycmd-mode-hook 'ycmd-eldoc-setup)
#+END_SRC
*** Clang-format
#+BEGIN_SRC emacs-lisp
  (use-package clang-format
    :init
    (add-hook 'c-mode-common-hook
	      (function (lambda () (local-set-key (kbd "TAB")
						  'clang-format-region)))))
#+END_SRC
** Bazel
#+BEGIN_SRC emacs-lisp
(use-package bazel-mode)
#+END_SRC
** SMT2
#+BEGIN_SRC emacs-lisp
  (setq auto-mode-alist (cons '("\\.smt2$" . lisp-mode) auto-mode-alist))
#+END_SRC
